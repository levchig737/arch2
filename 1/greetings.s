# 0 "greetings.S"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "<command-line>" 2
# 1 "greetings.S"
# 21 "greetings.S"
.data



    greeting: .asciz "Hello from Assembler!\n"
    enter: .asciz "\n"
    spaces: .asciz "                                                          "
    n: .long 21
    begin: .long 0




.text




    .global _start
    _start:



    movl $11, %esi # фиксируем счетчик повторений

  next:
    # Вывод пробелов вначале
    movl $4, %eax # помещаем номер системного вызова write
                            # в регистр eax
    movl $1, %ebx # помещаем номер дескриптора файла в регистр ebx,
                            # единица соответствует стандартному выводу, stdout
    leal spaces, %ecx # помещаем адрес выводимой строки в регистр ecx



                            # (объясните, почему не movl greeting, %ecx
    movl begin, %edx # помещаем в регистр edx количество байт, начиная с
                            # заданного адреса, которые нужно отправить в файл
    int $0x80 # обращаемся к обработчику системных вызовов


    # Вывод фразы основной greetings
    movl $4, %eax # помещаем номер системного вызова write
                            # в регистр eax
    movl $1, %ebx # помещаем номер дескриптора файла в регистр ebx,
                            # единица соответствует стандартному выводу, stdout
    leal greeting, %ecx # помещаем адрес выводимой строки в регистр ecx

    addl begin, %ecx # перемещаем указатель на адресс в памяти, чтобы начало сдвинуть
    addl $1, begin

                            # (объясните, почему не movl greeting, %ecx
    movl n, %edx # помещаем в регистр edx количество байт, начиная с
                            # заданного адреса, которые нужно отправить в файл
    int $0x80 # обращаемся к обработчику системных вызовов



    # Вывод перевода строки
    movl $4, %eax # помещаем номер системного вызова write
                            # в регистр eax
    movl $1, %ebx # помещаем номер дескриптора файла в регистр ebx,
                            # единица соответствует стандартному выводу, stdout
    leal enter, %ecx # помещаем адрес выводимой строки в регистр ecx
                            # (объясните, почему не movl greeting, %ecx
    movl $1, %edx # помещаем в регистр edx количество байт, начиная с
                            # заданного адреса, которые нужно отправить в файл
    int $0x80 # обращаемся к обработчику системных вызовов



    subl $2, n # Уменьшаем строку каждый раз

                            # ОС Linux, который выполняет вызов по его номеру
    subl $1, %esi # уменьшаем счетчик
    cmpl $1, %esi # если требуемое число повторений достигнуто,
    je bottom_clock # переходим к завершению программы
    jmp next # иначе повторяем еще раз



  # Второй цикл низа часов
  bottom_clock:
    movl $11, %esi # фиксируем счетчик повторений

    movl $3, n
    movl $9, begin

     # Вывод перевода строки
    movl $4, %eax # помещаем номер системного вызова write
                            # в регистр eax
    movl $1, %ebx # помещаем номер дескриптора файла в регистр ebx,
                            # единица соответствует стандартному выводу, stdout
    leal enter, %ecx # помещаем адрес выводимой строки в регистр ecx
                            # (объясните, почему не movl greeting, %ecx
    movl $1, %edx # помещаем в регистр edx количество байт, начиная с
                            # заданного адреса, которые нужно отправить в файл
    int $0x80 # обращаемся к обработчику системных вызовов


    jmp next_bottom


  next_bottom:
    # Вывод пробелов вначале
    movl $4, %eax # помещаем номер системного вызова write
                            # в регистр eax
    movl $1, %ebx # помещаем номер дескриптора файла в регистр ebx,
                            # единица соответствует стандартному выводу, stdout
    leal spaces, %ecx # помещаем адрес выводимой строки в регистр ecx


                            # (объясните, почему не movl greeting, %ecx
    movl begin, %edx # помещаем в регистр edx количество байт, начиная с
                            # заданного адреса, которые нужно отправить в файл
    int $0x80 # обращаемся к обработчику системных вызовов


    # Вывод фразы основной greetings
    movl $4, %eax # помещаем номер системного вызова write
                            # в регистр eax
    movl $1, %ebx # помещаем номер дескриптора файла в регистр ebx,
                            # единица соответствует стандартному выводу, stdout
    leal greeting, %ecx # помещаем адрес выводимой строки в регистр ecx

    addl begin, %ecx # перемещаем указатель на адресс в памяти, чтобы начало сдвинуть
    subl $1, begin

                            # (объясните, почему не movl greeting, %ecx
    movl n, %edx # помещаем в регистр edx количество байт, начиная с
                            # заданного адреса, которые нужно отправить в файл
    int $0x80 # обращаемся к обработчику системных вызовов



    # Вывод перевода строки
    movl $4, %eax # помещаем номер системного вызова write
                            # в регистр eax
    movl $1, %ebx # помещаем номер дескриптора файла в регистр ebx,
                            # единица соответствует стандартному выводу, stdout
    leal enter, %ecx # помещаем адрес выводимой строки в регистр ecx
                            # (объясните, почему не movl greeting, %ecx
    movl $1, %edx # помещаем в регистр edx количество байт, начиная с
                            # заданного адреса, которые нужно отправить в файл
    int $0x80 # обращаемся к обработчику системных вызовов



    addl $2, n # Уменьшаем строку каждый раз

                            # ОС Linux, который выполняет вызов по его номеру
    subl $1, %esi # уменьшаем счетчик
    cmpl $1, %esi # если требуемое число повторений достигнуто,
    je done # переходим к завершению программы
    jmp next_bottom # иначе повторяем еще раз



  done:



    movl $1, %eax # помещаем номер системного вызова _exit
                            # в регистр eax
    movl $0, %ebx # помещаем код возврата в регистр ebx,
                            # нулевой код соответствует успешному завершению
    int $0x80 # обращаемся к ОС

.end # последняя строка исходного текста
