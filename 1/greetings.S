/**
 * greetings.S -- выводит приветственную строку несколько раз
 *
 * Copyright (c) 2014 Petrozavodsk State University
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 */


/* Секция данных */

.data

    /* Размещаем нуль-терминальную строку в области глобальных
       инициализированных данных, метка greeting адресует строку */
    greeting: .asciz "Hello from Assembler!\n"
    enter: .asciz "\n"
    spaces: .asciz "                                                          "
    n: .long 21      # Кол-во байт на вывод теста
    begin: .long 0   # кол-во пробелов в начале строки


/* Секция команд процессора */

.text

    /* Метка _start адресует точку входа - первую инструкцию в секции
       команд процессора, которая будет исполнена при загрузке программы */
       
    .global _start
    _start:                           

    /* Многократно выводим строку на экран */
    
    movl $11, %esi          # фиксируем счетчик повторений
  
  next:
    # Вывод пробелов вначале
    movl $4, %eax           # помещаем номер системного вызова write
                            # в регистр eax                            
    movl $1, %ebx           # помещаем номер дескриптора файла в регистр ebx,
                            # единица соответствует стандартному выводу, stdout
    leal spaces, %ecx     # помещаем адрес выводимой строки в регистр ecx

    

                            
    movl begin, %edx          # помещаем в регистр edx количество байт, начиная с
                            # заданного адреса, которые нужно отправить в файл                        
    int  $0x80	            # обращаемся к обработчику системных вызовов


    # Вывод фразы основной greetings
    movl $4, %eax           # помещаем номер системного вызова write
                            # в регистр eax                            
    movl $1, %ebx           # помещаем номер дескриптора файла в регистр ebx,
                            # единица соответствует стандартному выводу, stdout
    leal greeting, %ecx     # помещаем адрес выводимой строки в регистр ecx

    addl begin, %ecx   # перемещаем указатель на адресс в памяти, чтобы начало сдвинуть
    addl $1, begin

                            
    movl n, %edx          # помещаем в регистр edx количество байт, начиная с
                            # заданного адреса, которые нужно отправить в файл                        
    int  $0x80	            # обращаемся к обработчику системных вызовов



    # Вывод перевода строки
    movl $4, %eax           # помещаем номер системного вызова write
                            # в регистр eax                            
    movl $1, %ebx           # помещаем номер дескриптора файла в регистр ebx,
                            # единица соответствует стандартному выводу, stdout
    leal enter, %ecx     # помещаем адрес выводимой строки в регистр ecx
                  
    movl $1, %edx          # помещаем в регистр edx количество байт, начиная с
                            # заданного адреса, которые нужно отправить в файл                        
    int  $0x80	            # обращаемся к обработчику системных вызовов



    subl $2, n # Уменьшаем строку каждый раз
  
                            # ОС Linux, который выполняет вызов по его номеру
    subl $1, %esi           # уменьшаем счетчик
    cmpl $1, %esi           # если требуемое число повторений достигнуто,
    je bottom_clock                 # переходим к завершению программы
    jmp next                # иначе повторяем еще раз



  # Второй цикл низа часов
  bottom_clock:
    movl $11, %esi          # фиксируем счетчик повторений

    movl $3, n
    movl $9, begin

    # Вывод перевода строки
    movl $4, %eax           # помещаем номер системного вызова write
                            # в регистр eax                            
    movl $1, %ebx           # помещаем номер дескриптора файла в регистр ebx,
                            # единица соответствует стандартному выводу, stdout
    leal enter, %ecx     # помещаем адрес выводимой строки в регистр ecx
                          
    movl $1, %edx          # помещаем в регистр edx количество байт, начиная с
                            # заданного адреса, которые нужно отправить в файл                        
    int  $0x80	            # обращаемся к обработчику системных вызовов


    jmp next_bottom
    

  next_bottom:
    # Вывод пробелов вначале
    movl $4, %eax           # помещаем номер системного вызова write
                            # в регистр eax                            
    movl $1, %ebx           # помещаем номер дескриптора файла в регистр ebx,
                            # единица соответствует стандартному выводу, stdout
    leal spaces, %ecx     # помещаем адрес выводимой строки в регистр ecx

    
    movl begin, %edx          # помещаем в регистр edx количество байт, начиная с
                            # заданного адреса, которые нужно отправить в файл                        
    int  $0x80	            # обращаемся к обработчику системных вызовов


    # Вывод фразы основной greetings
    movl $4, %eax           # помещаем номер системного вызова write
                            # в регистр eax                            
    movl $1, %ebx           # помещаем номер дескриптора файла в регистр ebx,
                            # единица соответствует стандартному выводу, stdout
    leal greeting, %ecx     # помещаем адрес выводимой строки в регистр ecx

    addl begin, %ecx   # перемещаем указатель на адресс в памяти, чтобы начало сдвинуть
    subl $1, begin

    movl n, %edx          # помещаем в регистр edx количество байт, начиная с
                            # заданного адреса, которые нужно отправить в файл                        
    int  $0x80	            # обращаемся к обработчику системных вызовов



    # Вывод перевода строки
    movl $4, %eax           # помещаем номер системного вызова write
                            # в регистр eax                            
    movl $1, %ebx           # помещаем номер дескриптора файла в регистр ebx,
                            # единица соответствует стандартному выводу, stdout
    leal enter, %ecx     # помещаем адрес выводимой строки в регистр ecx

    movl $1, %edx          # помещаем в регистр edx количество байт, начиная с
                            # заданного адреса, которые нужно отправить в файл                        
    int  $0x80	            # обращаемся к обработчику системных вызовов



    addl $2, n # Уменьшаем строку каждый раз
  
                            # ОС Linux, который выполняет вызов по его номеру
    subl $1, %esi           # уменьшаем счетчик
    cmpl $1, %esi           # если требуемое число повторений достигнуто,
    je done                # переходим к завершению программы
    jmp next_bottom             # иначе повторяем еще раз



  done:                            

    /* Завершаем выполнение программы с помощью системного вызова _exit */
    
    movl $1, %eax           # помещаем номер системного вызова _exit
                            # в регистр eax
    movl $0, %ebx           # помещаем код возврата в регистр ebx,
                            # нулевой код соответствует успешному завершению
    int  $0x80              # обращаемся к ОС

.end                        # последняя строка исходного текста